		device	zxspectrum128

numberOfBanks = 5
		include "pg1fx.inc"
		include "pg3fx.inc"
		include "pg4fx.inc"
		include "pg6fx.inc"
		include "pg7fx.inc"

		emptytap OUTPUT


@page128	equ	#7FFD
@act128page	equ	#5B5C
@actborder	equ	#5C48
@FRAMES		equ	#5C78
@RUNZONE	equ	#8400
@basesp		equ	RUNZONE


	module loader
		display "Composing loader & kernel"

		org	#7800
begin = $

introscr:	ld	hl,introscr.dat
		ld	de,#4000
		jr	introzx0.depack

fadeoutandrun:	ld	a,25
.loop:		ei
		halt
		halt
		ex	af,af'
		call	attrhide
		ex	af,af'
		dec	a
		jr	nz,.loop
		ld	hl,kernelblock.src
		ld	de,kernelblock.dest
		ld	bc,kernelblock.length
		ldir
		jp	kernel

unpackpage:	ld	hl,#51A1
		ld	bc,((30 / numberOfBanks) << 8) | #FF
.pgprog:	ld	(hl),c	; draw progress
		inc	l
		djnz	.pgprog
		ld	(unpackpage+1),hl
		di
		ld	hl,#8000
		ld	de,#C000

	module introzx0
depack
	opt push listoff
		include "dzx0_fast.a80"
	opt pop
	endmodule

attrhide:	ld	hl,22528
		ld	c,24
.atthd2:	ld	b,32
		push	bc
.atthd3:	ld	a,(hl)
		and	7
		jr	z,.atthd4
		dec	a
.atthd4:	push	af
		ld	a,(hl)
		and	56
		jr	z,.atthd5
		ld	c,8
		sub	c
		ld	c,a
		pop	af
		or	c
		jr	.atthd6
.atthd5:	ld	a,(hl)
		and	248
		ld	c,a
		pop	af
		or	c
.atthd6:	ld	(hl),a
		inc	hl
		djnz	.atthd3
		pop	bc
		dec	c
		jr	nz,.atthd2
		ret

kernelblock.src
		phase	#8000
kernelblock.dest

@xchg.vram:	ld	a,#1D
		xor	#0A
		ld	(xchg.vram+1),a
@xchg.bnk:	ld	(act128page),a
		ld	bc,page128
		out	(c),a
		ret

@depack:	module zx0
		include "dzx0_fast.a80"
		endmodule

;;-----------------------------------------------------------------------------
; Every part is defined with this effect descriptor:
;
;     db  fx_demopart.pg   ; current fx 128k page
;                          ; (set bit.7 to ldir given length, not decompress)
;     dw  fx_demopart      ; place where fx data lives
;     dw  fx_demopart.sync ; number of halts from start of demo to sync with
;     ... or ...
;     dw  fx_demopart.length

fxtable:
		db	fx_intro.pg
		dw	fx_intro
		dw	fx_intro.sync

		db	fx_micka.pg
		dw	fx_micka
		dw	fx_micka.sync

		db	fx_grinder.pg
		dw	fx_grinder
		dw	fx_grinder.sync

		db	fx_kitty_bank.pg + #80
		dw	fx_kitty_bank
		dw	fx_kitty_bank.length

		db	fx_plasma1.pg
		dw	fx_plasma1
		dw	fx_plasma1.sync

		db	fx_kitty.pg
		dw	fx_kitty
		dw	fx_kitty.sync

		db	fx_simon_bank.pg + #80
		dw	fx_simon_bank
		dw	fx_simon_bank.length

		db	fx_lucyshow.pg
		dw	fx_lucyshow
		dw	fx_lucyshow.sync

		db	fx_lucy.pg
		dw	fx_lucy
		dw	fx_lucy.sync

		db	fx_simon.pg
		dw	fx_simon
		dw	fx_simon.sync

		db	fx_plasma2.pg
		dw	fx_plasma2
		dw	fx_plasma2.sync

		db	0


	if $ > #8181
		display "Too long! ",/D,($-#8181)," bytes out of interrupt!"
	else
		display /D,(#8181-$)," bytes free before interrupt"
	endif

		block	(#8181-$),0

;;- INTERRUPT -----------------------------------------------------------------
;		org	#8181

interrupt:	push	af		; zakladne osetrenie prerusenia
		ld	a,(actborder)	; s volanim hudobneho hradla
		out	(254),a
		push	bc
		push	de
		push	hl
		exx
		ex	af,af'
		push	ix
		push	iy
		push	af
		push	bc
		push	de
		push	hl

		ld	a,MUSIC.page	; a prestrankujeme na banku s muzikou
		ld	bc,page128
		out	(c),a
		call	MUSIC.out
		ld	a,(act128page)
		ld	bc,page128
		out	(c),a

@IMCALL		ld	bc,#0101

		ld	hl,(FRAMES)
		inc	hl
		ld	(FRAMES),hl

		ld	a,(act128page)
		push	af
		and	#F8		; ponechame nastavenu vram
		or	MUSIC.page	; a prestrankujeme na banku s muzikou
		ld	bc,page128
		out	(c),a
		call	MUSIC.play
		pop	af
		ld	bc,page128
		out	(c),a

		pop	hl
		pop	de
		pop	bc
		pop	af
		pop	iy
		pop	ix
		ex	af,af'
		exx
		pop	hl
		pop	de
		pop	bc
		pop	af
		ei
		ret

im2vector = ((high $) + 1) << 8
		display /D,(im2vector-$)," bytes free to IM2 vector"
		block	(im2vector-$) + 257, 0

;;-----------------------------------------------------------------------------

@kernel:	di
		ld	sp,basesp
		ld	hl,im2vector
		ld	a,h
		ld	i,a
		im	2
		ld	a,high interrupt
.mkim2:		ld	(hl),a
		inc	l
		jr	nz,.mkim2
		inc	h
		ld	(hl),a
; init music
		ld	a,MUSIC.page | #10
		call	xchg.bnk
		call	MUSIC.init
; clear vram
		ld	hl,#4000
		ld	de,#4001
		ld	bc,#1AFF
		ld	(hl),l
		ldir
; outing of music to AY is delayed by one interrupt
		dec	bc
		ld	(FRAMES),bc
		ld	a,#10
		call	xchg.bnk

.run:		ld	hl,fxtable
		ld	a,(hl)
		or	a
		jr	z,.end
		inc	hl
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
		push	hl
		ex	de,hl
		ld	e,a
		and	#17
		ld	b,a
		ld	a,(act128page)
		and	#F8
		push	af
		or	b
		call	xchg.bnk
		bit	7,e
		jr	nz,.ldir
		ld	de,RUNZONE
		call	depack
		pop	af
		call	xchg.bnk
		pop	hl
		inc	hl
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ld	(.run+1),hl
		call	RUNZONE
		jr	.run

.ldir:		pop	af
		ex	de,hl
		pop	hl
		inc	l
		ld	c,(hl)
		inc	l
		ld	b,(hl)
		inc	l
		ld	(.run+1),hl
		ex	de,hl
		ld	de,RUNZONE
		ldir
		call	xchg.bnk
		call	RUNZONE
		jr	.run

.end		ei
		halt
		jr	.end

kernelblock.length = $ - kernelblock.dest

		display /D,(RUNZONE-$)," bytes free after kernel"
	dephase

introscr.dat:	incbin "loading.pak"

total = $-begin
	endmodule


		display "Composing BASIC"
		include "sinclairBASIC.inc"

		org	23755-17

; BASIC header
	tapout OUTPUT,0

		db	0
		db	C_STOP, "GENOCIDE "
		dw	bas.total
		dw	1 ; start line
		dw	bas.total

	tapend

; BASIC block
	tapout OUTPUT

	module bas
line1:		db	0, 1
		dw	line1.len
line1.cmds	; POKE VAL "23624",NOT PI:
		db	C_POKE
		VAL	23624, ','
		db	C_NOT, C_PI, ':'
		; POKE VAL "23693",NOT PI:
		db	C_POKE
		VAL	23693, ','
		db	C_NOT, C_PI, ':'
		; CLEAR VAL "x":
		db	C_CLEAR
		VAL	loader.begin - 1, ':'
		; POKE VAL "23739",CODE "o":
		db	C_POKE
		VAL	23739, ','
		db	C_CODE, '"o":'
		; POKE VAL "23388",VAL "16":
		db	C_POKE
		VAL	23388, ','
		VAL	16, ':'
		; OUT VAL "32765",VAL "16"
		db	C_OUT
		VAL	32765, ','
		VAL	16, ':'
		; LOAD _"loader" CODE:
		db	C_LOAD, ' "loader"', C_CODE, ':'
		; RANDOMIZE USR VAL "x"
		db	C_RANDOMIZE, C_USR
		VAL	loader.introscr, EOL
line1.len = $ - line1.cmds

line2:		db	0, 2
		dw	line2.len
line2.cmds	; READ s
		db	C_READ, 's:'
		; POKE VAL "23388",s:
		db	C_POKE
		VAL	23388, ','
		db	's:'
		; OUT VAL "32765",s:
		db	C_OUT
		VAL	32765, ','
		db	's:'
		; LOAD _"page"+(STR$ s) CODE:
		db	C_LOAD, ' "bank"+(', C_STRS, 's)', C_CODE, ':'
		; RANDOMIZE USR VAL "x":
		db	C_RANDOMIZE, C_USR
		VAL	loader.unpackpage, ':'
		; IF s <> VAL "23" THEN
		db	C_IF, 's', C_NOTEQ
		VAL	23, C_THEN
		; GO TO VAL "2"
		db	C_GOTO
		VAL	2, EOL
line2.len = $ - line2.cmds

line3:		db	0, 3
		dw	line3.len
		; PAUSE VAL "42"
		db	C_PAUSE
		VAL	42, ":"
line3.cmds	; RANDOMIZE USR VAL "x"
		db	C_RANDOMIZE, C_USR
		VAL	loader.fadeoutandrun, EOL
line3.len = $ - line3.cmds

line9:		db	0, 9
		dw	.len
line9.cmds	; DATA...
		db	C_DATA
		VAL	#11, ','
		VAL	#13, ','
		VAL	#14, ','
		VAL	#16, ','
		VAL	#17, EOL
line9.len = $ - line9.cmds

total = $ - line1
	endmodule
	tapend

; loader block
		display "Storing loader into output tape"
		savetap OUTPUT, CODE, "loader", loader.begin, loader.total

;;-----------------------------------------------------------------------------
	macro putBank number?, filename?
@__putBank_number = number?
		lua allpass
			_pl("putBank"..tostring(_c('__putBank_number')))
		endlua

		tapout OUTPUT,0
			db	3 ;; BYTES
		lua allpass
			_pc("db 'bank"..tostring(_c('__putBank_number')).."    '")
		endlua

			dw	.filelength
			dw	#8000 ;; block start address
			dw	#8000
		tapend

		tapout OUTPUT
			org #C000,(__putBank_number & 7)
.filedata		incbin filename?
.filelength = $-.filedata

	if .filelength > #4000
		display "Packed bank ",/D,(__putBank_number & 7)," is too long!"
	endif
		tapend
	endm
;;-----------------------------------------------------------------------------
		display "Storing banks into output tape"

		putBank #11,"../bank1.pak"
		putBank #13,"../bank3.pak"
		putBank #14,"../bank4.pak"
		putBank #16,"../bank6.pak"
		putBank #17,"../bank7.pak"


		export page128
		export act128page
		export actborder
		export FRAMES
		export basesp
		export kernel
		export IMCALL
		export RUNZONE
		export depack
		export xchg.vram
		export xchg.bnk
		export MUSIC.page
		export MUSIC.out
		export MUSIC.init
		export MUSIC.play
		export MUSIC.buffer
